import * as effector from 'effector';
import { Json, createStore, Store, Event, EventPayload, Effect, Subscription } from 'effector';
export { Json } from 'effector';

interface Contract<Raw, Data extends Raw> {
    /**
     * Checks if Response is some Data
     */
    isData: (prepared: Raw) => prepared is Data;
    /**
     * - `null` or empty array is dedicated for valid response
     * - array of string with validation erorrs for invalidDataError
     */
    getErrorMessages: (prepared: Raw) => string[];
}

declare const unknownContract: Contract<unknown, unknown>;

declare type FarfetchedError<T extends string> = {
    errorType: T;
    explanation: string;
};
declare const INVALID_DATA = "INVALID_DATA";
interface InvalidDataError extends FarfetchedError<typeof INVALID_DATA> {
    validationErrors: string[];
    response: unknown;
}
declare const TIMEOUT = "TIMEOUT";
interface TimeoutError extends FarfetchedError<typeof TIMEOUT> {
    timeout: number;
}
declare const ABORT = "ABORT";
interface AbortError extends FarfetchedError<typeof ABORT> {
}
declare const PREPARATION = "PREPARATION";
interface PreparationError extends FarfetchedError<typeof PREPARATION> {
    response: string;
    reason: string | null;
}
declare const HTTP = "HTTP";
interface HttpError<Status extends number = number> extends FarfetchedError<typeof HTTP> {
    status: Status;
    statusText: string;
    response: string | Json | null;
}
declare const NETWORK = "NETWORK";
interface NetworkError extends FarfetchedError<typeof NETWORK> {
    reason: string | null;
    cause?: unknown;
}

declare type Serialize<Data> = NonNullable<Parameters<typeof createStore<Data>>[1]>['serialize'];

declare type Callback<Data, Result> = (data: Data) => Result;
declare type CallbackWithSource<Data, Result, Source> = {
    source: Store<Source>;
    fn: (data: Data, source: Source) => Result;
};
declare type DynamicallySourcedField<Data, Result, Source> = Callback<Data, Result> | CallbackWithSource<Data, Result, Source>;
declare type SourcedField<Data, Result, Source> = Result | Store<Result> | Callback<Data, Result> | CallbackWithSource<Data, Result, Source>;
declare function normalizeSourced<Data, Result, Source>(config: {
    field: SourcedField<Data, Result, Source>;
    clock: Event<Data>;
}): Store<Result>;
declare function normalizeSourced<Data, Result, Source>(config: {
    field: SourcedField<Data, Result, Source>;
    source: Store<Data>;
}): Store<Result>;
declare type StaticOrReactive<T> = T | Store<Exclude<T, undefined>>;
declare function combineSourced(config: any, mapper?: (v: any) => any): any;

declare type FetchingStatus = 'initial' | 'pending' | 'done' | 'fail';

interface DefaultMeta {
    name: string;
}
interface RemoteOperation<Params, Data, Error, Meta> {
    /**
     * Reactive current request status
     *
     * + `initial` — the data has never been fetched yet
     * + 'pending' — the data is being fetched right now
     * + 'done' — the data has been successfully fetched
     * + 'fail' — an error occurred while fetching data
     */
    $status: Store<FetchingStatus>;
    /** Is fetching started? */
    $idle: Store<boolean>;
    /** Is fetching in progress right now? */
    $pending: Store<boolean>;
    /** Is fetching failed? */
    $failed: Store<boolean>;
    /** Is fetching succeeded? */
    $succeeded: Store<boolean>;
    /**
     * Is operation enabled?
     *
     * + false — any `start` call will be ignored, event done.skip will be fired immediately
     * + true — query will be executed after any `start` call
     */
    $enabled: Store<boolean>;
    /** Event to trigger query */
    start: Event<Params>;
    /** Set of events that represent end of query */
    finished: {
        /** Query was successfully ended, data will be passed as a payload */
        success: Event<{
            params: Params;
            result: Data;
            meta: ExecutionMeta;
        }>;
        /** Query was failed, error will be passed as a payload */
        failure: Event<{
            params: Params;
            error: Error;
            meta: ExecutionMeta;
        }>;
        /** Query execution was skipped due to `enabled` field in config */
        skip: Event<{
            params: Params;
            meta: ExecutionMeta;
        }>;
        /** Query was ended, it merges `success`, `error` and `skip` */
        finally: Event<{
            params: Params;
            meta: ExecutionMeta;
        }>;
    };
    /**
     * DO NOT USE THIS FIELD IN PRODUCTION
     *
     * It is internal operator details which is useful for testing.
     */
    __: {
        /**
         * Internal effect, which executes to retrieve data.
         *
         * It must not be used in production. Please use it only for test purposes.
         *
         * @example
         *
         * import { locationQuery } from './location';
         *
         * test('some test', async () => {
         *   const scope = fork({
         *     handlers: [[locationQuery.__.executeFx, vi.fn()]]
         *   });
         *
         *   //...test code
         * })
         */
        executeFx: Effect<any, any, any>;
        /**
         * Meta information about operation and its configuration.
         */
        meta: Meta & DefaultMeta;
        /**
         * Distinguish different kinds of operations
         */
        kind: unknown;
        $latestParams: Store<Params | null>;
        /**
         * Low-level API, it can be changed anytime without any notice!
         */
        lowLevelAPI: {
            dataSources: Array<DataSource<Params>>;
            dataSourceRetrieverFx: Effect<{
                params: Params;
            }, {
                result: unknown;
                stale: boolean;
            }, any>;
            sourced: SourcedField<Params, unknown, unknown>[];
            paramsAreMeaningless: boolean;
            revalidate: Event<{
                params: Params;
                refresh: boolean;
            }>;
        };
        experimentalAPI?: {
            attach: <Source, NewParams>(config: {
                source: Store<Source>;
                mapParams: (params: NewParams, source: Source) => Params;
            }) => any;
        };
    };
}
declare type RemoteOperationResult<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['finished']['success']>['result'];
declare type RemoteOperationError<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['finished']['failure']>['error'];
declare type RemoteOperationParams<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['start']>;
interface ExecutionMeta {
    stopErrorPropagation: boolean;
    stale: boolean;
}
declare type DataSource<Params> = {
    name: string;
    get: Effect<{
        params: Params;
    }, {
        result: unknown;
        stale: boolean;
    } | null, unknown>;
    set?: Effect<{
        params: Params;
        result: unknown;
    }, void, unknown>;
    unset?: Effect<{
        params: Params;
    }, void, unknown>;
};

interface QueryMeta<Data, InitialData> {
    /**
     * This field is used to determine how to serialize data in various cases:
     * - transfer state from server to client during SSR
     * - save state to persistent storage during caching
     */
    serialize: Serialize<Data | InitialData>;
    initialData: InitialData;
}
interface Query<Params, Data, Error, InitialData = null> extends RemoteOperation<Params, Data, Error, QueryMeta<Data, InitialData>> {
    /**
     * Start fetching data if it is absent or stale.
     */
    refresh: Event<Params>;
    /**
     * The reactive value of the latest received data.
     *
     * If there was an error during fetching or there has not been a request yet, the store will be `null`.
     */
    $data: Store<Data | InitialData>;
    /**
     * The reactive value of the data retrieval error.
     *
     * If the data was successfully fetched or there is no request yet, the store will be `null`.
     */
    $error: Store<Error | null>;
    /**
     * Is data stale?
     */
    $stale: Store<boolean>;
    /** Event to reset the whole state of the query */
    reset: Event<void>;
    '@@unitShape': () => {
        data: Store<Data | InitialData>;
        error: Store<Error | null>;
        stale: Store<boolean>;
        pending: Store<boolean>;
        start: Event<Params>;
    };
}
declare type QueryInitialData<Q extends Query<any, any, any, any>> = Q['__']['meta']['initialData'];

declare type ValidationResult = boolean | string | string[];
declare type Validator<Data, Params, ValidationSource> = DynamicallySourcedField<{
    result: Data;
    params: Params;
}, ValidationResult, ValidationSource>;

interface SharedQueryFactoryConfig<Data, Initial = Data> {
    name?: string;
    enabled?: StaticOrReactive<boolean>;
    serialize?: Serialize<Data | Initial>;
}
/**
 * Creates Query without any executor, it cannot be used as-is.
 *
 * @example
 * const headlessQuery = createHeadlessQuery()
 * headlessQuery.__.executeFx.use(someHandler)
 */
declare function createHeadlessQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource, ValidationSource, Initial = null>(config: {
    initialData?: Initial;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
    sourced?: SourcedField<Params, unknown, unknown>[];
    paramsAreMeaningless?: boolean;
} & SharedQueryFactoryConfig<MappedData, Initial>): Query<Params, MappedData, Error | InvalidDataError, Initial>;

declare function createQuery<Params, Response>(config: {
    handler: (p: Params) => Promise<Response>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, unknown>;
declare function createQuery<Params, Response>(config: {
    initialData: Response;
    handler: (p: Params) => Promise<Response>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, unknown, Response>;
declare function createQuery<Params, Response, Error, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    mapData: DynamicallySourcedField<{
        result: Response;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<MappedData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error>;
declare function createQuery<Params, Response, Error>(config: {
    effect: Effect<Params, Response, Error>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, Error>;
declare function createQuery<Params, Response, Error>(config: {
    initialData: Response;
    effect: Effect<Params, Response, Error>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, Error, Response>;
declare function createQuery<Params, Response, Error, ContractData extends Response, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<ContractData>): Query<Params, ContractData, Error | InvalidDataError>;
declare function createQuery<Params, Response, Error, ContractData extends Response, ValidationSource = void>(config: {
    initialData: ContractData;
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<ContractData>): Query<Params, ContractData, Error | InvalidDataError, ContractData>;
declare function createQuery<Params, Response, Error, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    initialData: MappedData;
    effect: Effect<Params, Response, Error>;
    mapData: DynamicallySourcedField<{
        result: Response;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<MappedData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error, MappedData>;
declare function createQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error | InvalidDataError>;
declare function createQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    initialData: MappedData;
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error | InvalidDataError, MappedData>;

declare type NonExtendable = {
    [K in string]: never;
};
declare function connectQuery<Sources, Target extends Query<any, any, any>>(args: {
    source: Sources;
    target: Target | [...Target[]];
} & (Target extends Query<infer P, any, any> ? P extends void ? {
    fn?: undefined;
} : Sources extends Query<any, any, any> ? {
    fn: (sources: {
        result: RemoteOperationResult<Sources>;
        params: RemoteOperationParams<Sources>;
    }) => {
        params: RemoteOperationParams<Target>;
    };
} : Sources extends Record<string, Query<any, any, any>> ? {
    fn: (sources: {
        [index in keyof Sources]: {
            result: RemoteOperationResult<Sources[index]>;
            params: RemoteOperationParams<Sources[index]>;
        };
    }) => {
        params: RemoteOperationParams<Target>;
    };
} : NonExtendable : NonExtendable)): void;

declare type FetchApiRecord = Record<string, string | string[] | number | boolean>;

declare type HttpMethod = 'HEAD' | 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'QUERY';
declare type ApiRequestError = AbortError | TimeoutError | PreparationError | NetworkError | HttpError;
declare type JsonApiRequestError = ApiRequestError | InvalidDataError;

interface ParamsDeclaration<T> {
    watch(cb: (payloaad: T) => void): Subscription;
}
declare function declareParams<T>(): ParamsDeclaration<T>;

declare type ConcurrencyConfig$1 = {
    strategy?: 'TAKE_EVERY' | 'TAKE_FIRST' | 'TAKE_LATEST';
    abort?: Event<void>;
};
declare type RequestConfig$1<Params, BodySource, QuerySource, HeadersSource, UrlSource> = {
    url: SourcedField<Params, string, UrlSource>;
    credentials?: RequestCredentials;
    query?: SourcedField<Params, FetchApiRecord, QuerySource> | SourcedField<Params, string, QuerySource>;
    headers?: SourcedField<Params, FetchApiRecord, HeadersSource>;
} & ({
    method: 'GET' | 'HEAD';
} | {
    method: Exclude<HttpMethod, 'GET' | 'HEAD'>;
    body?: SourcedField<Params, Json, BodySource>;
});
interface BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedQueryFactoryConfig<Data> {
    request: RequestConfig$1<void, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig$1;
}
interface BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedQueryFactoryConfig<Data> {
    params: ParamsDeclaration<Params>;
    request: RequestConfig$1<Params, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig$1;
}
declare function createJsonQuery<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
    };
}): Query<Params, TransformedData, JsonApiRequestError>;
declare function createJsonQuery<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: TransformedData;
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
    };
}): Query<Params, TransformedData, JsonApiRequestError, TransformedData>;
declare function createJsonQuery<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
    };
}): Query<Params, Data, JsonApiRequestError>;
declare function createJsonQuery<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: Data;
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
    };
}): Query<Params, Data, JsonApiRequestError, Data>;
declare function createJsonQuery<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
    };
}): Query<void, TransformedData, JsonApiRequestError>;
declare function createJsonQuery<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: TransformedData;
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
    };
}): Query<void, TransformedData, JsonApiRequestError, TransformedData>;
declare function createJsonQuery<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
    };
}): Query<void, Data, JsonApiRequestError>;
declare function createJsonQuery<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: Data;
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
    };
}): Query<void, Data, JsonApiRequestError, Data>;

interface Mutation<Params, Data, Error> extends RemoteOperation<Params, Data, Error, null> {
    '@@unitShape': () => {
        start: Event<Params>;
        pending: Store<boolean>;
    };
}

interface SharedMutationFactoryConfig {
    name?: string;
    enabled?: StaticOrReactive<boolean>;
}
declare function createHeadlessMutation<Params, Data, ContractData extends Data, MappedData, Error, MapDataSource = void, ValidationSource = void>(config: SharedMutationFactoryConfig & {
    contract: Contract<Data, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
}): Mutation<Params, MappedData, Error | InvalidDataError>;

declare function createMutation<Params, Data>(config: {
    handler: (params: Params) => Promise<Data>;
} & SharedMutationFactoryConfig): Mutation<Params, Data, unknown>;
declare function createMutation<Params, Data, Error>(config: {
    effect: Effect<Params, Data, Error>;
} & SharedMutationFactoryConfig): Mutation<Params, Data, Error>;
declare function createMutation<Params, Data, ContractData extends Data, Error>(config: {
    effect: Effect<Params, Data, Error>;
    contract: Contract<Data, ContractData>;
} & SharedMutationFactoryConfig): Mutation<Params, ContractData, Error | InvalidDataError>;

declare type ConcurrencyConfig = {
    abort?: Event<void>;
};
declare type RequestConfig<Params, BodySource, QuerySource, HeadersSource, UrlSource> = {
    url: SourcedField<Params, string, UrlSource>;
    credentials?: RequestCredentials;
    query?: SourcedField<Params, FetchApiRecord, QuerySource> | SourcedField<Params, string, QuerySource>;
    headers?: SourcedField<Params, FetchApiRecord, HeadersSource>;
} & ({
    method: 'GET' | 'HEAD';
} | {
    method: Exclude<HttpMethod, 'GET' | 'HEAD'>;
    body?: SourcedField<Params, Json, BodySource>;
});
interface BaseJsonMutationConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedMutationFactoryConfig {
    request: RequestConfig<void, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig;
}
interface BaseJsonMutationConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedMutationFactoryConfig {
    params: ParamsDeclaration<Params>;
    request: RequestConfig<Params, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig;
}
declare function createJsonMutation<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonMutationConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<Params, TransformedData, JsonApiRequestError>;
declare function createJsonMutation<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonMutationConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<Params, Data, JsonApiRequestError>;
declare function createJsonMutation<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonMutationConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<void, TransformedData, JsonApiRequestError>;
declare function createJsonMutation<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonMutationConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<void, Data, JsonApiRequestError>;

declare type MillisecondUnit = 'ms' | 'milli' | 'millisecond' | 'milliseconds';
declare type Millisecond = `${number}${MillisecondUnit}`;
declare type SecUnit = 's' | 'sec' | 'secs' | 'second' | 'seconds';
declare type Sec = `${number}${SecUnit}`;
declare type MinUnit = 'm' | 'min' | 'mins' | 'minute' | 'minutes';
declare type Min = `${number}${MinUnit}`;
declare type HourUnit = 'h' | 'hr' | 'hrs' | 'hour' | 'hours';
declare type Hour = `${number}${HourUnit}`;
declare type Time = `${Hour} ${Min} ${Sec}` | `${Hour} ${Min}` | `${Min} ${Sec}` | `${Hour}` | `${Min}` | `${Sec}` | `${Hour} ${Min} ${Sec} ${Millisecond}` | `${Hour} ${Min} ${Millisecond}` | `${Min} ${Sec} ${Millisecond}` | `${Hour} ${Millisecond}` | `${Min} ${Millisecond}` | `${Sec} ${Millisecond}` | `${Millisecond}` | number;

interface RetryMeta {
    attempt: number;
}

declare type FailInfo<Q extends RemoteOperation<any, any, any, any>> = {
    params: RemoteOperationParams<Q>;
    error: RemoteOperationError<Q>;
};
interface RetryConfig<Q extends RemoteOperation<any, any, any, any>, DelaySource = unknown, FilterSource = unknown, MapParamsSource = unknown> {
    times: StaticOrReactive<number>;
    delay: SourcedField<RetryMeta, Time, DelaySource>;
    filter?: SourcedField<FailInfo<Q>, boolean, FilterSource>;
    mapParams?: DynamicallySourcedField<FailInfo<Q> & {
        meta: RetryMeta;
    }, RemoteOperationParams<Q>, MapParamsSource>;
    otherwise?: Event<FailInfo<Q>>;
}
declare function retry<Q extends RemoteOperation<any, any, any, any>, DelaySource = unknown, FilterSource = unknown, MapParamsSource = unknown>(operation: Q, { times, delay: timeout, filter, mapParams, otherwise, }: RetryConfig<Q, DelaySource, FilterSource, MapParamsSource>): void;

interface DelayOptions {
    randomize: {
        spread: number;
    };
}
declare function linearDelay(base: number, opts?: DelayOptions): ({ attempt }: RetryMeta) => number;
declare function exponentialDelay(base: number, opts?: DelayOptions): ({ attempt }: RetryMeta) => number;

declare type QueryState<Q extends Query<any, any, any, any>> = {
    result: RemoteOperationResult<Q>;
    params: RemoteOperationParams<Q>;
} | {
    error: RemoteOperationError<Q>;
    params: RemoteOperationParams<Q>;
} | null;
declare type Refetch<Q extends Query<any, any, any, any>> = boolean | {
    params: RemoteOperationParams<Q>;
};
declare type RuleResult<Q extends Query<any, any, any, any>> = {
    result: RemoteOperationResult<Q>;
    refetch?: Refetch<Q>;
} | {
    error: RemoteOperationError<Q>;
    refetch?: Refetch<Q>;
};
declare function update<Q extends Query<any, any, any, any>, M extends Mutation<any, any, any>, BySuccessSource = void, ByFailureSource = void>(query: Q, { on: mutation, by: rules, }: {
    on: M;
    by: {
        success: DynamicallySourcedField<{
            query: QueryState<Q>;
            mutation: {
                result: RemoteOperationResult<M>;
                params: RemoteOperationParams<M>;
            };
        }, RuleResult<Q>, BySuccessSource>;
        failure?: DynamicallySourcedField<{
            query: QueryState<Q>;
            mutation: {
                error: RemoteOperationError<M>;
                params: RemoteOperationParams<M>;
            };
        }, RuleResult<Q>, ByFailureSource>;
    };
}): void;

declare function attachOperation<NewParams, Q extends Query<any, any, any, any>, Source>(operation: Q, config: {
    source: Store<Source>;
    mapParams: (params: NewParams, source: Source) => RemoteOperationParams<Q>;
}): Query<NewParams, RemoteOperationResult<Q>, RemoteOperationError<Q>, QueryInitialData<Q>>;
declare function attachOperation<NewParams, Q extends Query<any, any, any, any>>(operation: Q, config: {
    mapParams: (params: NewParams) => RemoteOperationParams<Q>;
}): Query<NewParams, RemoteOperationResult<Q>, RemoteOperationError<Q>, QueryInitialData<Q>>;
declare function attachOperation<Q extends Query<any, any, any, any>>(operation: Q): Q;
declare function attachOperation<NewParams, M extends Mutation<any, any, any>, Source>(operation: M, config: {
    source: Store<Source>;
    mapParams: (params: NewParams, source: Source) => RemoteOperationParams<M>;
}): Mutation<NewParams, RemoteOperationResult<M>, RemoteOperationError<M>>;
declare function attachOperation<NewParams, M extends Mutation<any, any, any>>(operation: M, config: {
    mapParams: (params: NewParams) => RemoteOperationParams<M>;
}): Mutation<NewParams, RemoteOperationResult<M>, RemoteOperationError<M>>;
declare function attachOperation<M extends Mutation<any, any, any>>(operation: M): M;

interface CacheAdapterInstance {
    get: Effect<{
        key: string;
    }, {
        value: unknown;
        cachedAt: number;
    } | null>;
    set: Effect<{
        key: string;
        value: unknown;
    }, void>;
    purge: Event<void>;
    unset: Effect<{
        key: string;
    }, void>;
}
interface CacheAdapterOptions {
    maxEntries?: number;
    maxAge?: Time;
    observability?: {
        hit?: Event<{
            key: string;
        }>;
        miss?: Event<{
            key: string;
        }>;
        expired?: Event<{
            key: string;
        }>;
        evicted?: Event<{
            key: string;
        }>;
    };
}
interface CacheAdapter extends CacheAdapterInstance {
    __: {
        $instance: Store<CacheAdapterInstance>;
    };
}

interface CacheParameters {
    adapter?: CacheAdapter;
    staleAfter?: Time;
    purge?: Event<void>;
}
declare function cache<Q extends Query<any, any, any, any>>(query: Q, rawParams?: CacheParameters): void;

interface NarrowObservability {
    hit?: Event<{
        key: string;
    }>;
    miss?: Event<{
        key: string;
    }>;
}
/**
 * @deprecated Write your own adapter instead by recipe — https://farfetched.pages.dev/recipes/server_cache.html
 */
declare function externalCache(config: {
    get: (opts: {
        key: string;
    }) => Promise<{
        value: unknown;
        cachedAt: number;
    } | null> | {
        value: unknown;
        cachedAt: number;
    } | null;
    set: (opts: {
        key: string;
        value: unknown;
    }) => Promise<void> | void;
    unset: (opts: {
        key: string;
    }) => Promise<void> | void;
    purge: () => Promise<void> | void;
    observability?: NarrowObservability;
}): CacheAdapter;

declare function inMemoryCache(config?: CacheAdapterOptions): CacheAdapter;

declare function localStorageCache(config?: CacheAdapterOptions): CacheAdapter;

declare function sessionStorageCache(config?: CacheAdapterOptions): CacheAdapter;

declare function voidCache(): CacheAdapter;

declare function createCacheAdapter(adapter: CacheAdapterInstance): CacheAdapter;

declare type JsonObject = Record<string, Json>;

/**
 * Effect wrapper for Fetch API
 *
 * It's used to declare static type of Error and mock requests in tests
 */
declare const fetchFx: effector.Effect<Request, Response, TypeError>;

declare function invalidDataError(config: {
    validationErrors: string[];
    response: unknown;
}): InvalidDataError;
declare function timeoutError(config: {
    timeout: number;
}): TimeoutError;
declare function abortError(): AbortError;
declare function preparationError(config: {
    response: string;
    reason: string | null;
}): PreparationError;
declare function httpError(config: {
    status: number;
    statusText: string;
    response: string | Json | null;
}): HttpError;
declare function networkError(config: {
    reason: string | null;
    cause?: unknown;
}): NetworkError;

declare type WithError<T = any, P = Record<string, unknown>> = P & {
    error: T;
};
declare function isInvalidDataError(args: WithError): args is WithError<InvalidDataError>;
declare function isTimeoutError(args: WithError): args is WithError<TimeoutError>;
declare function isAbortError(args: WithError): args is WithError<AbortError>;
declare function isPreparationError(args: WithError): args is WithError<PreparationError>;
declare function isHttpError(args: WithError): args is WithError<HttpError>;
declare function isHttpErrorCode<Code extends number>(code: Code): (args: WithError) => args is WithError<HttpError<Code>, Record<string, unknown>>;
declare function isNetworkError(args: WithError): args is WithError<NetworkError>;

declare type TriggerProtocol = {
    '@@trigger': () => {
        setup: Event<void>;
        teardown: Event<void>;
        fired: Event<unknown> | Event<void>;
    };
};

declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    automatically: true;
}): void;
declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    triggers: Array<Event<unknown> | Event<void> | TriggerProtocol>;
}): void;
declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    automatically: true;
    triggers: Array<Event<unknown> | Event<void> | TriggerProtocol>;
}): void;

export { AbortError, CacheAdapter, CacheAdapterOptions, Contract, DynamicallySourcedField, FarfetchedError, FetchApiRecord, FetchingStatus, HttpError, InvalidDataError, JsonObject, Mutation, NetworkError, ParamsDeclaration, PreparationError, Query, RemoteOperationError, RemoteOperationParams, RemoteOperationResult, SourcedField, TimeoutError, ValidationResult, Validator, abortError, attachOperation, cache, combineSourced, connectQuery, createCacheAdapter, createHeadlessMutation, createHeadlessQuery, createJsonMutation, createJsonQuery, createMutation, createQuery, declareParams, exponentialDelay, externalCache, fetchFx, httpError, inMemoryCache, invalidDataError, isAbortError, isHttpError, isHttpErrorCode, isInvalidDataError, isNetworkError, isPreparationError, isTimeoutError, keepFresh, linearDelay, localStorageCache, networkError, normalizeSourced, preparationError, retry, sessionStorageCache, timeoutError, unknownContract, update, voidCache };
