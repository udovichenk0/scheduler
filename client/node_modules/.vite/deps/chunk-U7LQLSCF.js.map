{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../use-sync-external-store/shim/with-selector.js", "../../effector-react/effector-react/createWatch.ts", "../../effector-react/effector-react/withDisplayName.ts", "../../effector-react/effector-react/apiBase.ts", "../../effector-react/effector-react/scope.ts", "../../effector-react/effector-react/nossr.ts", "../../effector-react/effector-react/createComponent.ts", "../../effector-react/effector-react/createStoreConsumer.ts", "../../effector-react/effector/config.ts", "../../effector-react/effector/is.ts", "../../effector-react/effector/throw.ts", "../../effector-react/effector-react/createGate.ts", "../../effector-react/effector-react/throw.ts", "../../effector-react/effector-react/useIsomorphicLayoutEffect.ts", "../../effector-react/effector-react/deprecate.ts", "../../effector-react/effector-react/createContextComponent.ts", "../../effector-react/effector-react/connect.ts", "../../effector-react/effector-react/createReactState.ts", "../../effector-react/effector/collection.ts"],
  "sourcesContent": ["/**\r\n * @license React\r\n * use-sync-external-store-shim.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n\r\n          'use strict';\r\n\r\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n}\r\n          var React = require('react');\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\nfunction is(x, y) {\r\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n  ;\r\n}\r\n\r\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\r\n\r\n// dispatch for CommonJS interop named imports.\r\n\r\nvar useState = React.useState,\r\n    useEffect = React.useEffect,\r\n    useLayoutEffect = React.useLayoutEffect,\r\n    useDebugValue = React.useDebugValue;\r\nvar didWarnOld18Alpha = false;\r\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\r\n// because of a very particular set of implementation details and assumptions\r\n// -- change any one of them and it will break. The most important assumption\r\n// is that updates are always synchronous, because concurrent rendering is\r\n// only available in versions of React that also have a built-in\r\n// useSyncExternalStore API. And we only use this shim when the built-in API\r\n// does not exist.\r\n//\r\n// Do not assume that the clever hacks used by this hook also work in general.\r\n// The point of this shim is to replace the need for hacks by other libraries.\r\n\r\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n// React do not expose a way to check if we're hydrating. So users of the shim\r\n// will need to track that themselves and return the correct value\r\n// from `getSnapshot`.\r\ngetServerSnapshot) {\r\n  {\r\n    if (!didWarnOld18Alpha) {\r\n      if (React.startTransition !== undefined) {\r\n        didWarnOld18Alpha = true;\r\n\r\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\r\n      }\r\n    }\r\n  } // Read the current snapshot from the store on every render. Again, this\r\n  // breaks the rules of React, and only works here because of specific\r\n  // implementation details, most importantly that updates are\r\n  // always synchronous.\r\n\r\n\r\n  var value = getSnapshot();\r\n\r\n  {\r\n    if (!didWarnUncachedGetSnapshot) {\r\n      var cachedValue = getSnapshot();\r\n\r\n      if (!objectIs(value, cachedValue)) {\r\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\r\n\r\n        didWarnUncachedGetSnapshot = true;\r\n      }\r\n    }\r\n  } // Because updates are synchronous, we don't queue them. Instead we force a\r\n  // re-render whenever the subscribed state changes by updating an some\r\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\r\n  // the current value.\r\n  //\r\n  // Because we don't actually use the state returned by the useState hook, we\r\n  // can save a bit of memory by storing other stuff in that slot.\r\n  //\r\n  // To implement the early bailout, we need to track some things on a mutable\r\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\r\n  // our useState hook instead.\r\n  //\r\n  // To force a re-render, we call forceUpdate({inst}). That works because the\r\n  // new object always fails an equality check.\r\n\r\n\r\n  var _useState = useState({\r\n    inst: {\r\n      value: value,\r\n      getSnapshot: getSnapshot\r\n    }\r\n  }),\r\n      inst = _useState[0].inst,\r\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\r\n  // in the layout phase so we can access it during the tearing check that\r\n  // happens on subscribe.\r\n\r\n\r\n  useLayoutEffect(function () {\r\n    inst.value = value;\r\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\r\n    // commit phase if there was an interleaved mutation. In concurrent mode\r\n    // this can happen all the time, but even in synchronous mode, an earlier\r\n    // effect may have mutated the store.\r\n\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n  }, [subscribe, value, getSnapshot]);\r\n  useEffect(function () {\r\n    // Check for changes right before subscribing. Subsequent changes will be\r\n    // detected in the subscription handler.\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n\r\n    var handleStoreChange = function () {\r\n      // TODO: Because there is no cross-renderer API for batching updates, it's\r\n      // up to the consumer of this library to wrap their subscription event\r\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\r\n      // the case and print a warning in development?\r\n      // The store changed. Check if the snapshot changed since the last time we\r\n      // read from the store.\r\n      if (checkIfSnapshotChanged(inst)) {\r\n        // Force a re-render.\r\n        forceUpdate({\r\n          inst: inst\r\n        });\r\n      }\r\n    }; // Subscribe to the store and return a clean-up function.\r\n\r\n\r\n    return subscribe(handleStoreChange);\r\n  }, [subscribe]);\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n\r\nfunction checkIfSnapshotChanged(inst) {\r\n  var latestGetSnapshot = inst.getSnapshot;\r\n  var prevValue = inst.value;\r\n\r\n  try {\r\n    var nextValue = latestGetSnapshot();\r\n    return !objectIs(prevValue, nextValue);\r\n  } catch (error) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\r\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n  // React do not expose a way to check if we're hydrating. So users of the shim\r\n  // will need to track that themselves and return the correct value\r\n  // from `getSnapshot`.\r\n  return getSnapshot();\r\n}\r\n\r\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\r\n\r\nvar isServerEnvironment = !canUseDOM;\r\n\r\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\r\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\r\n\r\nexports.useSyncExternalStore = useSyncExternalStore$2;\r\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n}\r\n        \r\n  })();\r\n}\r\n", "'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\r\n} else {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\r\n}\r\n", "/**\r\n * @license React\r\n * use-sync-external-store-shim/with-selector.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n\r\n          'use strict';\r\n\r\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n}\r\n          var React = require('react');\r\nvar shim = require('use-sync-external-store/shim');\r\n\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\nfunction is(x, y) {\r\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n  ;\r\n}\r\n\r\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\r\n\r\nvar useSyncExternalStore = shim.useSyncExternalStore;\r\n\r\n// for CommonJS interop.\r\n\r\nvar useRef = React.useRef,\r\n    useEffect = React.useEffect,\r\n    useMemo = React.useMemo,\r\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\r\n\r\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\r\n  // Use this to track the rendered snapshot.\r\n  var instRef = useRef(null);\r\n  var inst;\r\n\r\n  if (instRef.current === null) {\r\n    inst = {\r\n      hasValue: false,\r\n      value: null\r\n    };\r\n    instRef.current = inst;\r\n  } else {\r\n    inst = instRef.current;\r\n  }\r\n\r\n  var _useMemo = useMemo(function () {\r\n    // Track the memoized state using closure variables that are local to this\r\n    // memoized instance of a getSnapshot function. Intentionally not using a\r\n    // useRef hook, because that state would be shared across all concurrent\r\n    // copies of the hook/component.\r\n    var hasMemo = false;\r\n    var memoizedSnapshot;\r\n    var memoizedSelection;\r\n\r\n    var memoizedSelector = function (nextSnapshot) {\r\n      if (!hasMemo) {\r\n        // The first time the hook is called, there is no memoized result.\r\n        hasMemo = true;\r\n        memoizedSnapshot = nextSnapshot;\r\n\r\n        var _nextSelection = selector(nextSnapshot);\r\n\r\n        if (isEqual !== undefined) {\r\n          // Even if the selector has changed, the currently rendered selection\r\n          // may be equal to the new selection. We should attempt to reuse the\r\n          // current value if possible, to preserve downstream memoizations.\r\n          if (inst.hasValue) {\r\n            var currentSelection = inst.value;\r\n\r\n            if (isEqual(currentSelection, _nextSelection)) {\r\n              memoizedSelection = currentSelection;\r\n              return currentSelection;\r\n            }\r\n          }\r\n        }\r\n\r\n        memoizedSelection = _nextSelection;\r\n        return _nextSelection;\r\n      } // We may be able to reuse the previous invocation's result.\r\n\r\n\r\n      // We may be able to reuse the previous invocation's result.\r\n      var prevSnapshot = memoizedSnapshot;\r\n      var prevSelection = memoizedSelection;\r\n\r\n      if (objectIs(prevSnapshot, nextSnapshot)) {\r\n        // The snapshot is the same as last time. Reuse the previous selection.\r\n        return prevSelection;\r\n      } // The snapshot has changed, so we need to compute a new selection.\r\n\r\n\r\n      // The snapshot has changed, so we need to compute a new selection.\r\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\r\n      // has changed. If it hasn't, return the previous selection. That signals\r\n      // to React that the selections are conceptually equal, and we can bail\r\n      // out of rendering.\r\n\r\n      // If a custom isEqual function is provided, use that to check if the data\r\n      // has changed. If it hasn't, return the previous selection. That signals\r\n      // to React that the selections are conceptually equal, and we can bail\r\n      // out of rendering.\r\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\r\n        return prevSelection;\r\n      }\r\n\r\n      memoizedSnapshot = nextSnapshot;\r\n      memoizedSelection = nextSelection;\r\n      return nextSelection;\r\n    }; // Assigning this to a constant so that Flow knows it can't change.\r\n\r\n\r\n    // Assigning this to a constant so that Flow knows it can't change.\r\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\r\n\r\n    var getSnapshotWithSelector = function () {\r\n      return memoizedSelector(getSnapshot());\r\n    };\r\n\r\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\r\n      return memoizedSelector(maybeGetServerSnapshot());\r\n    };\r\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\r\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\r\n      getSelection = _useMemo[0],\r\n      getServerSelection = _useMemo[1];\r\n\r\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\r\n  useEffect(function () {\r\n    inst.hasValue = true;\r\n    inst.value = value;\r\n  }, [value]);\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n\r\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\r\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n}\r\n        \r\n  })();\r\n}\r\n", "'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\r\n} else {\r\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\r\n}\r\n", "import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [step.run({fn: value => fn(value)})]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n", "export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n", "import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues] = React.useMemo(() => {\n    flagsRef.current.stale = true\n    const shape = Array.isArray(normShape) ? [] : ({} as any)\n    const storeKeys: string[] = []\n    const storeValues: Array<Store<any>> = []\n    for (const key in normShape) {\n      const unit = normShape[key]\n      if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n      if (is.event(unit) || is.effect(unit)) {\n        shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n      } else {\n        shape[key] = null\n        storeKeys.push(key)\n        storeValues.push(unit as Store<any>)\n      }\n    }\n    return [shape, storeKeys, storeValues]\n  }, [flagsRef, scope, ...Object.keys(normShape), ...Object.values(normShape)])\n  const stateRef = React.useRef({value: eventsShape, storeKeys})\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldKeys = state.storeKeys\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (oldKeys.length !== storeKeys.length) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n", "import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n", "import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n", "import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n", "import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n", "import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n", "export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n", "export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n", "import {createStore, launch, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {useGateBase} from './apiBase'\nimport {getScope} from './scope'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function createGateImplementation<State>({\n  domain,\n  defaultState,\n  hook: useGateHook,\n  mainConfig,\n  maybeConfig,\n}: {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n}): Gate<State> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: mainConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config.name || 'gate'\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<State>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<State>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n    sid: config.sid,\n  })\n    .on(set, (_, state) => state)\n    .on(open, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props, getScope())\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\n\nconst isPluginConfig = (config: Record<string, any> | string) =>\n  isObject(config) && 'sid' in config\n\nconst isGateConfig = (config: Record<string, any> | string) =>\n  isObject(config) &&\n  ('domain' in config || 'defaultState' in config || 'name' in config)\n\nconst isStructuredConfig = (arg: unknown) =>\n  isObject(arg) && (arg.and || arg.or)\n\nexport function processCreateGateConfig<State>(\n  hook: typeof useGateBase,\n  args: unknown[],\n): {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n} {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n  const [[nameOrConfig, defaultStateOrConfig], metadata] =\n    processArgsToConfig(universalConfig)\n\n  let domain\n  let defaultState = {}\n  let mainConfig = {}\n  let maybeConfig = metadata\n\n  if (typeof nameOrConfig === 'string') {\n    mainConfig = {name: nameOrConfig}\n    if (isPluginConfig(defaultStateOrConfig)) {\n      // maybeConfig = defaultStateOrConfig\n    } else {\n      defaultState = defaultStateOrConfig || {}\n    }\n  } else if (isGateConfig(nameOrConfig)) {\n    mainConfig = nameOrConfig\n    defaultState = nameOrConfig.defaultState || {}\n    domain = nameOrConfig.domain\n  }\n  return {\n    hook,\n    domain,\n    defaultState,\n    mainConfig,\n    maybeConfig,\n  }\n}\n\nexport function createGate<Props>(...args: unknown[]): Gate<Props> {\n  return createGateImplementation<Props>(\n    processCreateGateConfig(useGateBase, args),\n  )\n}\n", "export const throwError = (message: string) => {\n  throw Error(message)\n}\n", "import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n", "export const deprecate = (method: string) =>\n  console.error(`${method} is deprecated`)\n", "import React from 'react'\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> => {\n  deprecate('createContextComponent')\n  return withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n}\n", "import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\n\nexport const connect =\n  <State>(Component: React.ComponentType<any>) =>\n  (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n", "import type {ComponentType} from 'react'\nimport type {Store} from 'effector'\n\nimport {connect} from './connect'\nimport {deprecate} from './deprecate'\n\nexport const createReactState = (\n  store: Store<any>,\n  View: ComponentType<any>,\n) => {\n  deprecate('createReactState')\n  return connect(View)(store)\n}\n", "export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAYA,QAAI,MAAuC;AACzC,OAAC,WAAW;AAEJ;AAGV,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,gCACpC,YACF;AACA,yCAA+B,4BAA4B,IAAI,MAAM,CAAC;AAAA,QACxE;AACU,YAAI,QAAQ;AAEtB,YAAI,uBAAuB,MAAM;AAEjC,iBAAS,MAAM,QAAQ;AACrB;AACE;AACE,uBAAS,QAAQ,UAAU,QAAQ,OAAO,IAAI,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,GAAG,QAAQ,GAAG,QAAQ,OAAO,SAAS;AACjH,qBAAK,QAAQ,CAAC,IAAI,UAAU,KAAK;AAAA,cACnC;AAEA,2BAAa,SAAS,QAAQ,IAAI;AAAA,YACpC;AAAA,UACF;AAAA,QACF;AAEA,iBAAS,aAAa,OAAO,QAAQ,MAAM;AAGzC;AACE,gBAAI,yBAAyB,qBAAqB;AAClD,gBAAI,QAAQ,uBAAuB,iBAAiB;AAEpD,gBAAI,UAAU,IAAI;AAChB,wBAAU;AACV,qBAAO,KAAK,OAAO,CAAC,KAAK,CAAC;AAAA,YAC5B;AAGA,gBAAI,iBAAiB,KAAK,IAAI,SAAU,MAAM;AAC5C,qBAAO,OAAO,IAAI;AAAA,YACpB,CAAC;AAED,2BAAe,QAAQ,cAAc,MAAM;AAI3C,qBAAS,UAAU,MAAM,KAAK,QAAQ,KAAK,GAAG,SAAS,cAAc;AAAA,UACvE;AAAA,QACF;AAMA,iBAAS,GAAG,GAAGA,IAAG;AAChB,iBAAO,MAAMA,OAAM,MAAM,KAAK,IAAI,MAAM,IAAIA,OAAM,MAAM,KAAKA,OAAMA;AAAA,QAErE;AAEA,YAAI,WAAW,OAAO,OAAO,OAAO,aAAa,OAAO,KAAK;AAI7D,YAAI,WAAW,MAAM,UACjB,YAAY,MAAM,WAClB,kBAAkB,MAAM,iBACxB,gBAAgB,MAAM;AAC1B,YAAI,oBAAoB;AACxB,YAAI,6BAA6B;AAWjC,iBAAS,qBAAqB,WAAW,aAIzC,mBAAmB;AACjB;AACE,gBAAI,CAAC,mBAAmB;AACtB,kBAAI,MAAM,oBAAoB,QAAW;AACvC,oCAAoB;AAEpB,sBAAM,gMAA+M;AAAA,cACvN;AAAA,YACF;AAAA,UACF;AAMA,cAAI,QAAQ,YAAY;AAExB;AACE,gBAAI,CAAC,4BAA4B;AAC/B,kBAAI,cAAc,YAAY;AAE9B,kBAAI,CAAC,SAAS,OAAO,WAAW,GAAG;AACjC,sBAAM,sEAAsE;AAE5E,6CAA6B;AAAA,cAC/B;AAAA,YACF;AAAA,UACF;AAgBA,cAAI,YAAY,SAAS;AAAA,YACvB,MAAM;AAAA,cACJ;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC,GACG,OAAO,UAAU,CAAC,EAAE,MACpB,cAAc,UAAU,CAAC;AAK7B,0BAAgB,WAAY;AAC1B,iBAAK,QAAQ;AACb,iBAAK,cAAc;AAKnB,gBAAI,uBAAuB,IAAI,GAAG;AAEhC,0BAAY;AAAA,gBACV;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF,GAAG,CAAC,WAAW,OAAO,WAAW,CAAC;AAClC,oBAAU,WAAY;AAGpB,gBAAI,uBAAuB,IAAI,GAAG;AAEhC,0BAAY;AAAA,gBACV;AAAA,cACF,CAAC;AAAA,YACH;AAEA,gBAAI,oBAAoB,WAAY;AAOlC,kBAAI,uBAAuB,IAAI,GAAG;AAEhC,4BAAY;AAAA,kBACV;AAAA,gBACF,CAAC;AAAA,cACH;AAAA,YACF;AAGA,mBAAO,UAAU,iBAAiB;AAAA,UACpC,GAAG,CAAC,SAAS,CAAC;AACd,wBAAc,KAAK;AACnB,iBAAO;AAAA,QACT;AAEA,iBAAS,uBAAuB,MAAM;AACpC,cAAI,oBAAoB,KAAK;AAC7B,cAAI,YAAY,KAAK;AAErB,cAAI;AACF,gBAAI,YAAY,kBAAkB;AAClC,mBAAO,CAAC,SAAS,WAAW,SAAS;AAAA,UACvC,SAASC,QAAP;AACA,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,iBAAS,uBAAuB,WAAW,aAAa,mBAAmB;AAKzE,iBAAO,YAAY;AAAA,QACrB;AAEA,YAAI,YAAY,CAAC,EAAE,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AAEvI,YAAI,sBAAsB,CAAC;AAE3B,YAAI,OAAO,sBAAsB,yBAAyB;AAC1D,YAAI,yBAAyB,MAAM,yBAAyB,SAAY,MAAM,uBAAuB;AAErG,gBAAQ,uBAAuB;AAE/B,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,+BACpC,YACF;AACA,yCAA+B,2BAA2B,IAAI,MAAM,CAAC;AAAA,QACvE;AAAA,MAEE,GAAG;AAAA,IACL;AAAA;AAAA;;;AC9OA;AAAA;AAAA;AAEA,QAAI,OAAuC;AACzC,aAAO,UAAU;AAAA,IACnB,OAAO;AACL,aAAO,UAAU;AAAA,IACnB;AAAA;AAAA;;;ACNA;AAAA;AAAA;AAYA,QAAI,MAAuC;AACzC,OAAC,WAAW;AAEJ;AAGV,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,gCACpC,YACF;AACA,yCAA+B,4BAA4B,IAAI,MAAM,CAAC;AAAA,QACxE;AACU,YAAI,QAAQ;AACtB,YAAI,OAAO;AAMX,iBAAS,GAAG,GAAGC,IAAG;AAChB,iBAAO,MAAMA,OAAM,MAAM,KAAK,IAAI,MAAM,IAAIA,OAAM,MAAM,KAAKA,OAAMA;AAAA,QAErE;AAEA,YAAI,WAAW,OAAO,OAAO,OAAO,aAAa,OAAO,KAAK;AAE7D,YAAI,uBAAuB,KAAK;AAIhC,YAAI,SAAS,MAAM,QACf,YAAY,MAAM,WAClB,UAAU,MAAM,SAChB,gBAAgB,MAAM;AAE1B,iBAAS,iCAAiC,WAAW,aAAa,mBAAmB,UAAU,SAAS;AAEtG,cAAI,UAAU,OAAO,IAAI;AACzB,cAAI;AAEJ,cAAI,QAAQ,YAAY,MAAM;AAC5B,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,OAAO;AAAA,YACT;AACA,oBAAQ,UAAU;AAAA,UACpB,OAAO;AACL,mBAAO,QAAQ;AAAA,UACjB;AAEA,cAAI,WAAW,QAAQ,WAAY;AAKjC,gBAAI,UAAU;AACd,gBAAI;AACJ,gBAAI;AAEJ,gBAAI,mBAAmB,SAAU,cAAc;AAC7C,kBAAI,CAAC,SAAS;AAEZ,0BAAU;AACV,mCAAmB;AAEnB,oBAAI,iBAAiB,SAAS,YAAY;AAE1C,oBAAI,YAAY,QAAW;AAIzB,sBAAI,KAAK,UAAU;AACjB,wBAAI,mBAAmB,KAAK;AAE5B,wBAAI,QAAQ,kBAAkB,cAAc,GAAG;AAC7C,0CAAoB;AACpB,6BAAO;AAAA,oBACT;AAAA,kBACF;AAAA,gBACF;AAEA,oCAAoB;AACpB,uBAAO;AAAA,cACT;AAIA,kBAAI,eAAe;AACnB,kBAAI,gBAAgB;AAEpB,kBAAI,SAAS,cAAc,YAAY,GAAG;AAExC,uBAAO;AAAA,cACT;AAIA,kBAAI,gBAAgB,SAAS,YAAY;AASzC,kBAAI,YAAY,UAAa,QAAQ,eAAe,aAAa,GAAG;AAClE,uBAAO;AAAA,cACT;AAEA,iCAAmB;AACnB,kCAAoB;AACpB,qBAAO;AAAA,YACT;AAIA,gBAAI,yBAAyB,sBAAsB,SAAY,OAAO;AAEtE,gBAAI,0BAA0B,WAAY;AACxC,qBAAO,iBAAiB,YAAY,CAAC;AAAA,YACvC;AAEA,gBAAI,gCAAgC,2BAA2B,OAAO,SAAY,WAAY;AAC5F,qBAAO,iBAAiB,uBAAuB,CAAC;AAAA,YAClD;AACA,mBAAO,CAAC,yBAAyB,6BAA6B;AAAA,UAChE,GAAG,CAAC,aAAa,mBAAmB,UAAU,OAAO,CAAC,GAClD,eAAe,SAAS,CAAC,GACzB,qBAAqB,SAAS,CAAC;AAEnC,cAAI,QAAQ,qBAAqB,WAAW,cAAc,kBAAkB;AAC5E,oBAAU,WAAY;AACpB,iBAAK,WAAW;AAChB,iBAAK,QAAQ;AAAA,UACf,GAAG,CAAC,KAAK,CAAC;AACV,wBAAc,KAAK;AACnB,iBAAO;AAAA,QACT;AAEA,gBAAQ,mCAAmC;AAE3C,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,+BACpC,YACF;AACA,yCAA+B,2BAA2B,IAAI,MAAM,CAAC;AAAA,QACvE;AAAA,MAEE,GAAG;AAAA,IACL;AAAA;AAAA;;;ACpKA;AAAA;AAAA;AAEA,QAAI,OAAuC;AACzC,aAAO,UAAU;AAAA,IACnB,OAAO;AACL,aAAO,UAAU;AAAA,IACnB;AAAA;AAAA;;;AW6HyCC,mBAAAA;AAAAC,2BAAAA;AAAAA,kBAAAA;AVjIlC,SAASC,EACdC,IACAC,IACAC,IACAC,IAAAA;AAAAA,MAEMC,KAAa,CAACC,GAAKC,IAAI,EAACL,IAAIM,CAAAA,OAASN,GAAGM,EAAAA,EAAAA,CAAAA,CAAAA;AAAAA,MAC1CJ,MAAWC,GAAII,QAAQL,EAAAA,GACvBD,IAAO;AAAA,QACHO,KAAOC,EAAW,EAACD,MAAML,GAAAA,CAAAA,GACzBO,KAAMX,GAAcY,SAASD,IAC7BE,KAAqCX,GAAcY,iBACnDC,KAAQF,GAAWF,EAAAA,KAAO,CAAA;AAAA,WAChCE,GAAWF,EAAAA,IAAMI,IACjBA,GAAMC,KAAKP,EAAAA,GACJ,MAAA;AAAA,UACCQ,KAAMF,GAAMG,QAAQT,EAAAA;AAAAA,aACtBQ,MAAYF,GAAMI,OAAOF,IAAK,CAAA,GAClCG,GAAUX,EAAAA;IAAAA;EAAAA;AAEP;AAAA,QACCA,KAAOC,EAAW,EACtBD,MAAML,IACNiB,QAAQ,CAACrB,EAAAA,GACTsB,QAAQ,EAACC,QAAQvB,GAAAA,EAAAA,CAAAA;AAAAA,WAEZ,MAAA;AACLoB,SAAUX,EAAAA;IAAAA;EAAAA;AAAAA;AC7BT,SAASe,EAAgBC,IAAcC,IAAAA;AAAAA,SAC5CA,GAAUC,cAAcF,IACjBC;AAAAA;AC0BF,SAASE,GAAoB5B,IAAqBE,IAAAA;AAClD2B,KAAG7B,MAAMA,EAAAA,KAAQ8B,EAAW,wCAAA;AAAA,MAE3BC,KAAYC,aAAAA,QAAMC,YACrBC,CAAAA,OAAmBnC,EAAYC,IAAOkC,IAAIhC,EAAAA,GAC3C,CAACF,IAAOE,EAAAA,CAAAA,GAEJiC,KAAOH,aAAAA,QAAMC,YACjB,MAAMG,EAAYpC,IAAOE,EAAAA,GACzB,CAACF,IAAOE,EAAAA,CAAAA;AAAAA,SAEWmC,EAAqBN,IAAWI,IAAMA,EAAAA;AAAAA;AAKtD,SAASG,EACdC,IACArC,IAAAA;AAAAA,MAEMsC,KAAeX,GAAGY,KAAKF,EAAAA,GACzBG,KAAwC,CAAA;AACxCF,EAAAA,KACFE,KAAY,EAACD,MAAMF,GAAAA,IACV,iBAAiBA,KACU,cAAA,OAAzBA,GAAM,aAAA,IACfG,KAAYH,GAAM,aAAA,EAAA,IAElBT,EAAW,qCAAA,IAGbY,KAAYH;AAAAA,MAERI,KAASC,MAAMC,QAAQH,EAAAA,GACvBI,KAAWd,aAAAA,QAAMe,OAAO,EAC5BC,OAAO,GACPC,gBAAgB,GAChB/C,OAAAA,GAAAA,CAAAA,GAAAA,CAEKgD,IAAaC,IAAWC,EAAAA,IAAepB,aAAAA,QAAMqB,QAAQ,MAAA;AAC1DP,IAAAA,GAASQ,QAAQN,QAAQ;AAAA,QACnBT,KAAQK,MAAMC,QAAQH,EAAAA,IAAa,CAAA,IAAM,CAAA,GACzCS,KAAsB,CAAA,GACtBC,KAAiC,CAAA;AAAA,aAC5BG,MAAOb,IAAW;AAAA,UACrBD,KAAOC,GAAUa,EAAAA;AAClB1B,SAAGY,KAAKA,EAAAA,KAAOX,EAAW,sCAAA,GAC3BD,GAAG2B,MAAMf,EAAAA,KAASZ,GAAG4B,OAAOhB,EAAAA,IAC9BF,GAAMgB,EAAAA,IAAOrD,KAAQwD,EAAUjB,IAAoB,EAACvC,OAAAA,GAAAA,CAAAA,IAAUuC,MAE9DF,GAAMgB,EAAAA,IAAO,MACbJ,GAAUnC,KAAKuC,EAAAA,GACfH,GAAYpC,KAAKyB,EAAAA;IAAAA;AAAAA,WAGd,CAACF,IAAOY,IAAWC,EAAAA;EAAAA,GACzB,CAACN,IAAU5C,IAAAA,GAAUyD,OAAOC,KAAKlB,EAAAA,GAAAA,GAAeiB,OAAOE,OAAOnB,EAAAA,CAAAA,CAAAA,GAC3DoB,KAAW9B,aAAAA,QAAMe,OAAO,EAACxC,OAAO2C,IAAaC,WAAAA,GAAAA,CAAAA,GAC7CpB,KAAYC,aAAAA,QAAMC,YACrBC,CAAAA,OAAAA;AAAAA,QACO6B,KAAQjB,GAASQ;AACvBS,IAAAA,GAAMd,iBAAiB;AAAA,QACjBe,KAAW,MAAA;AACVD,MAAAA,GAAMf,UACTe,GAAMf,QAAQ,GACdd,GAAAA;IAAAA,GAGE/B,KAAYE,GAAK4D,QAAQ,EAACC,UAAU,WAAWC,OAAO,EAAA,CAAA,GACtDC,KAAOhB,GAAYiB,IAAIrE,CAAAA,OAC3BD,EAAYC,IAAOgE,IAAU9D,IAAOC,EAAAA,CAAAA;AAAAA,WAE/B,MAAA;AACLiE,MAAAA,GAAKE,QAAQrE,CAAAA,OAAMA,GAAAA,CAAAA;IAAAA;EAAAA,GAGvB,CAACmD,IAAalD,IAAO4D,IAAUhB,EAAAA,CAAAA,GAE3BX,KAAOH,aAAAA,QAAMC,YAAY,MAAA;AAAA,QAGzBsC,IAFEC,KAAQV,GAASR,SACjBS,KAAQjB,GAASQ,SAEnBmB,KAAU,GACRC,KAASF,GAAMjE,OACfoE,KAAUH,GAAMrB,WAChByB,KAAe1E,OAAU6D,GAAM7D;AAAAA,QACjC6D,GAAMf,SAASe,GAAMd,kBAAkB2B,IAAc;AACvDH,MAAAA,KAAAA,CAAWV,GAAMd,kBAAkB2B,IACnCL,KAAc5B,KAAS,CAAA,GAAIO,EAAAA,IAAe,EAAA,GAAIA,GAAAA,GAC1CyB,GAAQE,WAAW1B,GAAU0B,WAC/BJ,KAAU;AAAA,eAEHK,KAAI,GAAGA,KAAI3B,GAAU0B,QAAQC,MAAK;AAAA,YACnCC,KAAe3C,EAAYgB,GAAY0B,EAAAA,GAAI5E,EAAAA,GAC3CqD,KAAMJ,GAAU2B,EAAAA;AACjBL,QAAAA,OAIDA,KAHGE,GAAQK,SAASzB,EAAAA,IAGVmB,GAAOnB,EAAAA,MAASwB,KAFhB,IAKdR,GAAYhB,EAAAA,IAAOwB;MAAAA;IAAAA;AAAAA,WAGnBN,OACFD,GAAMjE,QAAQgE,KAEhBC,GAAMrB,YAAYA,IAClBY,GAAMf,QAAQ,GACde,GAAMd,iBAAAA,CAAkBwB,IACxBV,GAAM7D,QAAQA,IACPsC,KAAegC,GAAMjE,MAAMkC,OAAO+B,GAAMjE;EAAAA,GAC9C,CAACwB,IAAWqB,IAAalD,IAAO4D,IAAUhB,EAAAA,CAAAA;AAAAA,SACtCT,EAAqBN,IAAWI,IAAMA,EAAAA;AAAAA;AAGxC,SAAS8C,EAAAA,CACbC,IAAeC,EAAAA,GAYhBjF,IAAAA;AAAAA,MAEID,IAGAmF,IACApF,IACA4D,IAJAyB,KACFC;AAIEH,EAAAA,MACFlF,KAAKkF,IACLnF,KAAQkF,IACRtB,KAAO,CAAA,KAAA,EAGL3D,IAAAA,IACAD,OAAAA,IACA4D,MAAAA,IACAwB,cAAAA,IACAC,cAAAA,KAAeC,EAAAA,IACbJ,IAEDrD,GAAG7B,MAAMA,EAAAA,KAAQ8B,EAAW,6BAAA,GAC5Bc,MAAMC,QAAQe,EAAAA,KAAO9B,EAAW,sCAAA,GACnB,cAAA,OAAP7B,MAAmB6B,EAAW,gCAAA;AAAA,MAEnCC,KAAYC,aAAAA,QAAMC,YACrBC,CAAAA,OAAmBnC,EAAYC,IAAOkC,IAAIhC,EAAAA,GAC3C,CAACF,IAAOE,EAAAA,CAAAA,GAEJiC,KAAOH,aAAAA,QAAMC,YACjB,MAAMG,EAAYpC,IAAOE,EAAAA,GACzB,CAACF,IAAOE,EAAAA,CAAAA,GAGJ4D,KAAW9B,aAAAA,QAAMe,OAAAA,GACjBwC,KAAWvD,aAAAA,QAAMe,OAAAA,GACjByC,KAAUxD,aAAAA,QAAMe,OAAOa,EAAAA;AAAAA,SAEf6B,EACZ1D,IACAI,IACAA,IACAqC,CAAAA,OAAAA;AAAAA,QACMV,GAASR,YAAYkB,MAAAA,EA5Lb,CAACkB,IAAoBC,OAAAA;AAAAA,UAAAA,CAChCD,MAAAA,CAAMC,MAAKD,GAAEb,WAAWc,GAAEd;AAAQ,eAAO;AAAA,UAE1Ce,KAAU;AAAA,eAELd,KAAI,GAAGA,KAAIY,GAAEb,QAAQC;AAAAA,YACxBY,GAAEZ,EAAAA,MAAOa,GAAEb,EAAAA,GAAI;AACjBc,UAAAA,KAAU;AAAA;QAAA;AAAA,aAKPA;IAAAA,GAgL0CJ,GAAQlC,SAASM,EAAAA,GAAO;AAAA,UAC/DiC,KAAS5F,GAAGuE,IAAOZ,EAAAA;AAAAA,iBACnBiC,MAAAA,WAAwBT,OAC1BS,KAAST,KAEXtB,GAASR,UAAUkB,IACnBgB,GAAQlC,UAAUM,IAAAA,WAMdiC,OACFN,GAASjC,UAAUuC;IAAAA;AAAAA,WAIhBN,GAASjC;EAAAA,GAElB,CAACA,IAASwC,OAAAA,CAAYT,GAAaS,IAAQxC,EAAAA,CAAAA;AAAAA;AAoHxC,SAASyC,GACdC,IACAC,KAAe,CAAA,GACf/F,IAAAA;AAAAA,MAAAA,EAEMgG,MAACA,IAADC,OAAOA,IAAPC,KAAcA,GAAAA,IAAO9D,EACzB,EACE4D,MAAMF,GAAcE,MACpBC,OAAOH,GAAcG,OACrBC,KAAKJ,GAAcI,IAAAA,GAErBlG,EAAAA,GAEImG,KAAarE,aAAAA,QAAMqB,QACvB,OAAA,EAEI6C,MAAAA,IACAC,OAAAA,IACAC,KAAAA,GAAAA,IAEJ,CAACJ,IAAeE,EAAAA,CAAAA,GAGZI,KAAWtE,aAAAA,QAAMe,OAAoC,EACzDxC,OAAO,MACPgG,OAAO,EAAA,CAAA;AAETC,IAA0B,OACxBH,GAAWH,KAAKI,GAAShD,QAAQ/C,KAAAA,GAC1B,MAAM8F,GAAWF,MAAMG,GAAShD,QAAQ/C,KAAAA,IAC9C,CAAC8F,EAAAA,CAAAA,IAUN,CAAwBX,IAAQC,OAAAA;AAAAA,QAC1BD,OAAMC;AAAG,aAAO;AAAA,QAEL,YAAA,OAAND,MACD,SAANA,MACa,YAAA,OAANC,MACD,SAANA,IACA;AAAA,UACMc,KAAQ9C,OAAOC,KAAK8B,EAAAA,GACpBgB,KAAQ/C,OAAOC,KAAK+B,EAAAA;AAAAA,UACtBc,GAAM5B,WAAW6B,GAAM7B;AAAQ,eAAO;AAAA,eACjCC,KAAI,GAAGA,KAAI2B,GAAM5B,QAAQC,MAAK;AAAA,YAC/BvB,KAAMkD,GAAM3B,EAAAA;AAAAA,YACdY,GAAEnC,EAAAA,MAASoC,GAAEpC,EAAAA;AAAM,iBAAO;MAAA;AAAA,aAEzB;IAAA;AAAA,WAEF;EAAA,GA1Ba+C,GAAShD,QAAQ/C,OAAO0F,EAAAA,MAC1CK,GAAShD,QAAQ/C,QAAQ0F,IACzBK,GAAShD,QAAQiD,SAAS,IAE5BC,EAA0B,MAAA;AACxBH,IAAAA,GAAWD,IAAIE,GAAShD,QAAQ/C,KAAAA;EAAAA,GAC/B,CAAC+F,GAAShD,QAAQiD,KAAAA,CAAAA;AAAAA;AC/WhB,SAASI,EAASC,IAAAA;AAAAA,MACjB1G,KAAQ8B,aAAAA,QAAM6E,WAAWC,CAAAA;AAAAA,SAC3BF,MAAAA,CAAe1G,MACjB4B,EAAW,wDAAA,GACN5B;AAAAA;ACOF,SAAS6G,EACdvD,IACAwD,IAAAA;AAAAA,UFySK,CAAsBC,IAAkB/G,OAAAA;AAAAA,QAAAA,CACxCA;AAAAA,aACI+G;AAAAA,QAGHC,KADWrF,GAAGY,KAAKwE,EAAAA,KAAuC,YAAA,OAAhBA,KACT,EAACzD,OAAOyD,GAAAA,IAAtBA;AAAAA,WAElBjF,aAAAA,QAAMqB,QAAQ,MAAA;AAAA,UACfxB,GAAGY,KAAKwE,EAAAA;AAAAA,eAEHvD,EAAUuD,IAAa,EAAC/G,OAAAA,GAAAA,CAAAA;AAAAA,UAE3BqC,KAAQK,MAAMC,QAAQoE,EAAAA,IAAe,CAAA,IAAM,CAAA;AAAA,eACtC1D,MAAO0D;AAChB1E,QAAAA,GAAMgB,EAAAA,IAAOG,EAAUuD,GAAY1D,EAAAA,GAAM,EAACrD,OAAAA,GAAAA,CAAAA;AAAAA,aAErCqC;IAAAA,GACN,CAACrC,IAAAA,GAAUyD,OAAOC,KAAKsD,EAAAA,GAAAA,GAAYvD,OAAOE,OAAOqD,EAAAA,CAAAA,CAAAA;EAAAA,GEtThC1D,IAFNmD,EAASK,QAAAA,KAAAA,SAAAA,GAAMJ,UAAAA,CAAAA;AAAAA;AAKxB,SAASO,EACdnH,IACAgH,IAAAA;AAAAA,SAEOpF,GAAa5B,IAAO2G,EAASK,QAAAA,KAAAA,SAAAA,GAAMJ,UAAAA,CAAAA;AAAAA;AAGrC,SAASQ,GAAQ7E,IAAOyE,IAAAA;AAAAA,SACtB1E,EAAYC,IAAOoE,EAASK,QAAAA,KAAAA,SAAAA,GAAMJ,UAAAA,CAAAA;AAAAA;AAGpC,SAASS,EACdnC,IAUAC,IAAAA;AAAAA,SAEOF,EACL,CAACC,IAAeC,EAAAA,GAChBwB,EAASzB,QAAAA,KAAAA,SAAAA,GAAe0B,UAAAA,CAAAA;AAAAA;AAIrB,SAASU,EACdC,IACAC,IAQAR,IAAAA;AAAAA,UF+JK,CACLO,IACAC,IAQAtH,OAAAA;AAAAA,QAGID,IACAwH,IACAC,IAHA9D,KAAO,CAAA;AAIe,gBAAA,OAAf4D,MAA0C,SAAfA,MAChCA,GAAW5D,SAAMA,KAAO4D,GAAW5D,OAAAA,EACpC3D,IAAAA,IAAIwH,QAAAA,IAAQC,aAAAA,GAAAA,IAAeF,MAE9BvH,KAAKuH,IAEF3F,GAAG7B,MAAMuH,EAAAA,KAAOzF,EAAW,6CAAA,GACd,cAAA,OAAP7B,MACT6B,EAAW,8CAAA,GACRc,MAAMC,QAAQe,EAAAA,KAAO9B,EAAW,sCAAA;AAAA,QAC/B6F,KAAO3F,aAAAA,QAAMqB,QAAQ,MAAA;AAAA,UACnBsE,KAAOnG,EACV,GAAE+F,GAAKK,aAAa,kBAEnB3B,CAAAA,OAAAA;AAAAA,YAAAA,EAIM4B,OAACA,IAADjE,MAAQA,IAARkE,QAAcA,IAAdvH,OAAsBA,GAAAA,IAAS0F;AAAAA,YACnB8B,GAAMzE,QAAQ,CAAA;AAAA,iBAEvByE,GAAMzE,QAAQ,CAAA,EAAG/C,IAAOuH,EAAAA;AAAAA,YAE3BE,KAAO/C,EACX,CACE,EACEjF,OAAOuH,IACP3D,MAAM,CAACiE,IAAAA,GAAUjE,EAAAA,GACjB3D,IAAI,CAACsH,IAAM3D,OAAS2D,GAAK3D,GAAK,CAAA,CAAA,EAAA,CAAA,GAGlC1D,EAAAA;AAAAA,eAEK6H,GAAMzE,QAAQ,CAAA,EAAG0E,IAAMH,EAAAA;MAAAA,CAAAA;AAAAA,aAG3B7F,aAAAA,QAAMiG,KAAKN,EAAAA;IAAAA,GACjB,CAACJ,IAAMrH,IAAAA,CAAAA,CAASuH,EAAAA,CAAAA,GACbM,KAAQ/F,aAAAA,QAAMe,OAAO,CAAC9C,IAAIwH,EAAAA,CAAAA;AAChCM,IAAAA,GAAMzE,UAAU,CAACrD,IAAIwH,EAAAA;AAAAA,QACfS,KAAelG,aAAAA,QAAMqB,QAAQ,MAAMO,IAAMA,EAAAA;AAAAA,QAC3C6D,IAAS;AAAA,UACLU,KAAYvG,GAAa2F,IAAMrH,EAAAA;AAAAA,aACZ,MAArBiI,GAAUtD,UAAgB6C,KAAoBA,KAC3CS,GAAU9D,IAAI9D,CAAAA,OAAAA;AAAAA,YACbgD,KAAMwE,GAAMzE,QAAQ,CAAA,EAAG/C,EAAAA;AAAAA,eACtByB,aAAAA,QAAMoG,cAAcT,IAAM,EAC/BG,QAAQvE,IACRA,KAAAA,IACAK,MAAMsE,IACN3H,OAAAA,GAAAA,CAAAA;MAAAA,CAAAA;IAAAA;AAGC;AAAA,UACCsE,KAASI,EACb,CACE,EACEjF,OAAOuH,IACP3D,MAAM,CAAC2D,EAAAA,GACPtH,IAAIsH,CAAAA,OAAQA,GAAK1C,OAAAA,CAAAA,GAGrB3E,EAAAA;AAAAA,aAEa,MAAX2E,MAAgB6C,KAAoBA,KACjC9E,MAAMyF,KAAK,EAACxD,QAAAA,GAAAA,GAAS,CAACyD,IAAGxD,OAC9B9C,aAAAA,QAAMoG,cAAcT,IAAM,EACxBE,OAAO/C,IACPvB,KAAKuB,IACLlB,MAAMsE,GAAAA,CAAAA,CAAAA;IAAAA;EAAAA,GElPOX,IAAMC,IAAYb,EAASK,QAAAA,KAAAA,SAAAA,GAAMJ,UAAAA,CAAAA;AAAAA;AAG/C,SAAS2B,GACdvC,IACAC,KAAe,CAAA,GACfe,IAAAA;AAAAA,SAEOjB,GAAYC,IAAeC,IAAOU,EAASK,QAAAA,KAAAA,SAAAA,GAAMJ,UAAAA,CAAAA;AAAAA;ACpEnD,SAAS4B,EACdjG,IACAkG,IAAAA;AAAAA,WAkBSC,GAAgBzC,IAAAA;AAAAA,QACjBK,KAAWtE,aAAAA,QAAMe,OAAOkD,EAAAA,GACxBzB,KAAQ2C,EAASnH,EAAAA;AACvBwG,MAA0B,OACxBmC,GAAQ,EAAC1C,OAAOK,GAAShD,SAASkB,OAAOxE,GAAM4I,SAAAA,EAAAA,CAAAA,GACxC,MAAA;AACLC,MAAAA,GAAU,EAAC5C,OAAOK,GAAShD,SAASkB,OAAOxE,GAAM4I,SAAAA,EAAAA,CAAAA;IAAAA,IAElD,CAAA,CAAA;AAAA,QACG/C,KAAS4C,GAAWxC,IAAOzB,EAAAA;AAAAA,WACjC8B,GAAShD,UAAU2C,IACZJ;EAAAA;AAAAA,MA3BL7F;AACA6B,KAAG7B,MAAMuC,EAAAA,IACXvC,KAAQuC,KAEa,YAAA,OAAVA,MAAgC,SAAVA,KAC/BvC,KAAQ8I,EAAQvG,EAAAA,IACXT,EAAW,+CAAA;AAAA,MAEhBiH,KAAY;AAEZ/I,EAAAA,MAASA,GAAM4H,cACjBmB,KAAY/I,GAAM4H;AAAAA,MAEde,KAAUK,EAAAA,GACVH,KAAYG,EAAAA;AAAAA,SAelBN,GAAgBC,UAAUA,IAC1BD,GAAgBG,YAAYA,IACrBrH,EAAiB,GAAEuH,WAAkBL,EAAAA;AAAAA;ACtCvC,SAASO,GACdjJ,IAAAA;AAAAA,SAEOwI,EAAgBxI,IAAO,CAAA,EAAEkJ,UAAAA,GAAAA,GAAW1E,OAAU0E,GAAS1E,EAAAA,CAAAA;AAAAA;ACAzD,SAAS2E,EACdrJ,IACAsJ,IAAAA;AAAAA,MAEMC,KAAYD,KAAiBtJ,KAAOA,GAAK,CAAA;ACGpBS,MAAAA;ACftB,GAAgB+I,CAAAA,OAAAA;AAAAA,QAAAA,CAChBA;AAAW,YAAMC,MDiBpB,oCAAA;EAAA,GADAC,EAFyBjJ,KDFd8I,EAAAA,MCHY9I,CAAAA,OACR,cAAA,OAAVA,IAMyBA,EAAAA,CAAAA;AAAAA,MDH5BkJ,KAAWJ,GAAUK,IACnBC,KAAcN,GAAUO;AAAAA,MAC1BD,IAAa;AAAA,QACTE,KAAuBT,KAAiBO,KAAcA,GAAY,CAAA;AAAA,QAOnEH,EAASK,EAAAA,KAA2B,SAASA,IAE3C;AAAA,UAECC,KAASX,EAAoBQ,IAAaP,EAAAA;AAEhDtJ,MAAAA,KAAOgK,GAAO,CAAA,GACdL,KAAW,EAAA,GAAIA,IAAAA,GAAaK,GAAO,CAAA,EAAA;IAAA;AANnChK,MAAAA,KAAO6J;EAAAA;AAAAA,SASJ,CAAC7J,IAAM2J,EAAAA;AAAAA;AGsDT,SAASM,EACdC,IACAlK,IAAAA;AAAAA,MAQMmK,KACJnK,MAbF0J,EAD0BU,KAcGpK,GAAK,CAAA,CAAA,MAbhBoK,GAAIN,OAAOM,GAAIR,MAaO5J,KAAO,CAAC,EAAC8J,KAAK9J,GAAAA,CAAAA;AAd5BoK,MAAAA;AAAAA,MAkBtBC,IAAAA,CAAAA,CAHIC,IAAcC,EAAAA,GAAuBZ,EAAAA,IAC3CN,EAAoBc,EAAAA,GAGlBK,KAAe,CAAA,GACfC,KAAa,CAAA,GACbC,KAAcf;AA5BIgB,MAAAA;AAAAA,SA8BM,YAAA,OAAjBL,MACTG,KAAa,EAAC9I,MAAM2I,GAAAA,GA9BtBZ,EADsBiB,KAgCDJ,EAAAA,KA/BD,SAASI,OAkCzBH,KAAeD,MAAwB,CAAA,OAhCvBI,CAAAA,OACpBjB,EAASiB,EAAAA,MACR,YAAYA,MAAU,kBAAkBA,MAAU,UAAUA,KAgCrCL,EAAAA,MACtBG,KAAaH,IACbE,KAAeF,GAAaE,gBAAgB,CAAA,GAC5CH,KAASC,GAAaD,SAEjB,EACLH,MAAAA,IACAG,QAAAA,IACAG,cAAAA,IACAC,YAAAA,IACAC,aAAAA,GAAAA;AAAAA;AAIG,SAASE,KAAqB5K,IAAAA;AAAAA,UAzH9B,CAAA,EAAyCqK,QAC9CA,IAD8CG,cAE9CA,IACAN,MAAMW,IAHwCJ,YAI9CA,IAJ8CC,aAK9CA,GAAAA,MAAAA;AAAAA,aAqDSxE,GAAcC,IAAAA;AAAAA,aACrB0E,GAAY3E,IAAsBC,IAAOU,EAAAA,CAAAA,GAClC;IAAA;AAAA,QA/CH8D,KAASG,EAAc,EAC3BlB,IAAIc,IACJZ,KAAKW,GAAAA,CAAAA,GAGDM,KAAY,GAAEV,KAAU,GAAEA,GAAOW,cAAcD,cAAc,KADtDJ,GAAOhJ,QAAQ,UAEtB2E,KAAM4C,EAAmB,EAC7BvH,MAAO,GAAEoJ,UACTE,KAAKN,GAAOM,MAAO,GAAEN,GAAOM,YAAAA,OAAYC,CAAAA,GAEpC9E,KAAO8C,EAAmB,EAC9BvH,MAAO,GAAEoJ,WACTE,KAAKN,GAAOM,MAAO,GAAEN,GAAOM,aAAAA,OAAaC,CAAAA,GAErC7E,KAAQ6C,EAAmB,EAC/BvH,MAAO,GAAEoJ,YACTE,KAAKN,GAAOM,MAAO,GAAEN,GAAOM,cAAAA,OAAcC,CAAAA,GAEtCC,KAASC,EAAYC,QAAQ,CAAA,GAAQ,EACzC1J,MAAO,GAAEoJ,aACTO,WAAW,SAAA,CAAA,EAGVC,GAAGnF,IAAM,MAAMiF,QAAQ,CAAA,CAAA,EACvBE,GAAGlF,IAAO,MAAMgF,QAAQ,CAAA,CAAA,GACrB3G,KAAQ0G,EAAYZ,IAAuB,EAC/C7I,MAAO,GAAEoJ,YACTE,KAAKN,GAAOM,IAAAA,CAAAA,EAEXM,GAAGjF,IAAK,CAACkC,IAAG9D,OAAUA,EAAAA,EACtB6G,GAAGnF,IAAM,CAACoC,IAAG9D,OAAUA,EAAAA,EACvB8G,MAAMnF,EAAAA;AAAAA,QACLgE,IAAQ;AAAA,UAAA,EACJoB,OAACA,GAAAA,IAASpB;AAChBqB,QAAO,EACLC,QAAQ,CACNF,GAAMvL,OACNuL,GAAMvL,OACNuL,GAAM/H,OACN+H,GAAM/H,OACN+H,GAAM/H,KAAAA,GAERkI,QAAQ,CAACT,IAAQzG,IAAO0B,IAAMC,IAAOC,EAAAA,EAAAA,CAAAA;IAAAA;AAAAA,WAOzCJ,GAAcE,OAAOA,IACrBF,GAAcG,QAAQA,IACtBH,GAAciF,SAASA,IACvBjF,GAAcxB,QAAQA,IACtBwB,GAAcI,MAAMA,IACb5E,EAAiB,QAAOqJ,MAAY7E,EAAAA;EAAAA,GAwDzC+D,EAAwBhE,IAAajG,EAAAA,CAAAA;AAAAA;ACnIlC,IAAMgC,IAAc6J,CAAAA,OAAAA;AAAAA,QACnBpC,MAAMoC,EAAAA;AAAAA;AADP,ICEMnF,IACO,eAAA,OAAXoF,SAAyB5J,aAAAA,QAAM6J,kBAAkB7J,aAAAA,QAAM8J;AAAAA,IAAAA,EAAAA,sBAAAA,EAAAA,IAAAA,YAAAA;AAAAA,IAAAA,EAAAA,kCAAAA,EAAAA,IAAAA,qBAAAA;AAAAA,IVO1D1J,IAAc,CAAIpC,IAAiBE,OACvCA,KAAQA,GAAM0I,SAAS5I,EAAAA,IAASA,GAAM4I,SAAAA;AURwBkD,IVS1DxG,IAAoB,CAAIyG,IAAQC,OAAgBD,OAAQC;AUTEF,ITC1DhF,IAAe9E,aAAAA,QAAMiK,cAAc,IAAA;AAAA,IAAA,EAC5BC,UAACA,EAAAA,IAAYpF;AADe,IUJ5BqF,IAAaC,CAAAA,OACxBC,QAAQC,MAAO,GAAEF,kBAAAA;AVGsB,IWE5BG,IAAyB,CACpCvM,IACAwM,IACA/D,QAEA0D,EAAU,wBAAA,GACH3K,EACJ,GAAExB,GAAM4H,aAAa,8BACrB3B,CAAAA,OAAAA;AAAAA,MACOwG,KAAMzK,aAAAA,QAAM6E,WAAW2F,EAAAA,GACvBhI,KAAQ2C,EAASnH,EAAAA;AAAAA,SAChByI,GAAWxC,IAAOzB,IAAOiI,EAAAA;AAAAA,CAAAA;AXbG,IYE5BC,IACHhL,CAAAA,OACP1B,CAAAA,OAAAA;AAAAA,MACK2M,KAAYjL;AAAAA,SACS,cAAA,OAAdA,OACTiL,KAAO3M,IACPA,KAAQ0B,KAGHF,EAAiB,WADKmL,GAAKhL,eAAegL,GAAKlL,QAAQ,cACFwE,CAAAA,OAC1DjE,aAAAA,QAAMoG,cAAcuE,IAAM,EAAA,GAAI1G,IAAAA,GAAUkB,EAASnH,EAAAA,EAAAA,CAAAA,CAAAA;AAAAA;AZZd,IaE5B4M,IAAmB,CAC9B5M,IACA2M,QAEAR,EAAU,kBAAA,GACHO,EAAQC,EAAAA,EAAM3M,EAAAA;AbPkB,IKI5BwJ,IAAYjJ,CAAAA,OACN,YAAA,OAAVA,MAAgC,SAAVA;ALLU,II8C5BqK,IAAgB,CAACiC,IAAWpC,KAA8B,CAAA,OACjEjB,EAASqD,EAAAA,MACXjC,EAAciC,GAAKnD,IAAIe,EAAAA,IUnDzBqC,CAAAA,OAAAA;AAAAA,WAGWvJ,MAAOuJ;AViDIC,IAAAA,KUhDPxJ,KTQMhD,CAAAA,OAAAA,WAAkCA,IDwCxCA,KUhDVuM,GAAIvJ,EAAAA,CAAAA,KViD2B,SAAVwJ,MAA4B,UAAVA,OACtCtC,GAAOsC,EAAAA,IAASxM;AAFR,MAACA,IAAOwM;AAAAA,GAAdF,EAAAA,GAKNjC,EAAciC,GAAKjD,KAAKa,EAAAA,IAEnBA;",
  "names": ["y", "error", "y", "args", "args", "createWatch", "store", "fn", "scope", "batchStep", "seq", "step", "run", "value", "unshift", "node", "createNode", "id", "graphite", "scopeLinks", "additionalLinks", "links", "push", "idx", "indexOf", "splice", "clearNode", "parent", "family", "owners", "withDisplayName", "name", "Component", "displayName", "useStoreBase", "is", "throwError", "subscribe", "React", "useCallback", "cb", "read", "stateReader", "useSyncExternalStore", "useUnitBase", "shape", "isSingleUnit", "unit", "normShape", "isList", "Array", "isArray", "flagsRef", "useRef", "stale", "justSubscribed", "eventsShape", "storeKeys", "storeValues", "useMemo", "current", "key", "event", "effect", "scopeBind", "Object", "keys", "values", "stateRef", "flags", "cbCaller", "compute", "priority", "batch", "subs", "map", "forEach", "resultValue", "state", "changed", "oldVal", "oldKeys", "scopeChanged", "length", "i", "updatedValue", "includes", "useStoreMapBase", "configOrStore", "separateFn", "defaultValue", "updateFilter", "basicUpdateFilter", "valueRef", "keysRef", "useSyncExternalStoreWithSelector", "a", "b", "isEqual", "result", "update", "useGateBase", "GateComponent", "props", "open", "close", "set", "ForkedGate", "propsRef", "count", "useIsomorphicLayoutEffect", "aKeys", "bKeys", "getScope", "forceScope", "useContext", "ScopeContext", "useEvent", "opts", "eventObject", "events", "useStore", "useUnit", "useStoreMap", "useList", "list", "renderItem", "getKey", "placeholder", "Item", "shortName", "index", "keyVal", "fnRef", "item", "memo", "keysSelfMemo", "listItems", "createElement", "from", "_", "useGate", "createComponent", "renderProp", "RenderComponent", "mounted", "getState", "unmounted", "combine", "storeName", "createEvent", "createStoreConsumer", "children", "processArgsToConfig", "singleArgument", "rawConfig", "condition", "Error", "isObject", "metadata", "or", "childConfig", "and", "unwrappedNestedValue", "nested", "processCreateGateConfig", "hook", "universalConfig", "arg", "domain", "nameOrConfig", "defaultStateOrConfig", "defaultState", "mainConfig", "maybeConfig", "config", "createGate", "useGateHook", "flattenConfig", "fullName", "compositeName", "sid", "undefined", "status", "createStore", "Boolean", "serialize", "on", "reset", "hooks", "launch", "target", "params", "message", "window", "useLayoutEffect", "useEffect", "upd", "oldValue", "createContext", "Provider", "deprecate", "method", "console", "error", "createContextComponent", "context", "ctx", "connect", "View", "createReactState", "part", "obj", "field"]
}
